/*
 * This file and its contents are supplied under the terms of the
 * Common Development and Distribution License ("CDDL"), version 1.0.
 * You may only use this file in accordance with the terms of version
 * 1.0 of the CDDL.
 *
 * A full copy of the text of the CDDL should have accompanied this
 * source.  A copy of the CDDL is also available via the Internet at
 * http://www.illumos.org/license/CDDL.
 */

/*
 * Copyright 2021 Oxide Computer Company
 */

/*
 * This file defines both the userspace ioctl API/ABI as well as the
 * ktest module API/ABI. The later is everything hidden behind the
 * _KERNEL guard.
 *
 * TODO: mandoc covering this entire API.
 */
#ifndef	_SYS_KTEST_H
#define	_SYS_KTEST_H

#include <sys/types.h>

#ifdef __cplusplus
extern "C" {
#endif

#define	KTEST_SEPARATOR		":"
#define	KTEST_DEF_TRIPLE	"*:*:*"
#define	KTEST_DEF_TRIPLE_SZ	6
#define	KTEST_MAX_NAME_LEN	64
#define	KTEST_MAX_LOG_LEN       4096
#define	KTEST_MODULE_KEY	"module"
#define	KTEST_SUITE_KEY		"suite"
#define	KTEST_SUITE_INIT_KEY	"init"
#define	KTEST_SUITE_FINI_KEY	"fini"
#define	KTEST_TEST_KEY		"test"
#define	KTEST_LINENO_KEY	"lineno"
#define	KTEST_GMATCH_CHARS	"*?[]"

#define	KTEST_SER_FMT_KEY	"ser_fmt_version"
#define	KTEST_SER_FMT_VSN	1

/*
 * TODO: probably want to move this comment to a big theory statement
 * in ktest.c.
 *
 * All tests are registered under a unique name called a "triple",
 * made up of the test's module name, suite name, and test name. A
 * triple value which uses the test's exact name is a fully-qualified
 * triple. A triple can also be specified using glob patterns,
 * matching zero or more tests; this type of triple is also called a
 * "filter". Some tests require an input stream to run. In order to
 * execute such tests you must specify a fully-qualified triple along
 * with the input stream. This is referred to as a "quad".
 *
 * Examples of filters:
 *
 * *:*:*
 * mac:*:*
 * mac:checksum:*
 * mac:checksum:ipv4*
 *
 * Example of a quad:
 *
 * mac:checksum:ipv4_input:<bytes of snoop stream>
 */
#define	KTEST_INPUT_KEY		"input"
#define	KTEST_INPUT_PATH_KEY	"input_path"
#define	KTEST_TRIPLE_KEY	"triple"

#define	KTEST_IOCTL	(('k' << 16) | ('t' << 8))

typedef enum ktest_ioctl {
	KTEST_IOCTL_RUN_TESTS	= (KTEST_IOCTL | 1),
	KTEST_IOCTL_LIST_TESTS	= (KTEST_IOCTL | 2),
	KTEST_IOCTL_READ_MSGS	= (KTEST_IOCTL | 3),
} ktest_ioctl_t;

/*
 * Flags used to alter the behavior of ktest or convey additional
 * information about the test. Passed as the final argument to
 * ktest_add_test(9F).
 *
 * KTF_INPUT
 *
 *    This test requires an input stream.
 *
 */
typedef enum ktest_test_flags {
	KTF_NONE	= 0,
	KTF_INPUT	= (1 << 0),
} ktest_test_flags_t;

#define	PATH_MAX		1024

/*
 * At the moment we support glob matching only (via gmatch()). The
 * kernel provides no regex support, and glob matching should suffice.
 *
 * TODO: Document format of triples buf.
 */
typedef struct ktest_run_op {
	char		*kro_triples_buf;
	size_t		kro_triples_len;
} ktest_run_op_t;

typedef struct ktest_list_op {
	char		*klo_triples_buf;
	size_t		klo_triples_len;
	char		*klo_resp;
	size_t		klo_resp_len;
} ktest_list_op_t;

/*
 * KTEST_UNINIT: This value is used as a sentinel to detect if the
 * test result was not set.
 *
 * KTEST_PASS: The test executed as expected and all assertions were true.
 *
 * KTEST_FAIL: The test executed as expected but encountered an
 * assertion that resolved to false. The test result will include a
 * message generated by one of the KT assertion macros.
 *
 * KTEST_SKIP: The test decided it should not run for whatever reason.
 * The typical reason for skipping is when the test relies on specific
 * hardware or a feature that is not available in the current context.
 *
 * KTEST_ERROR: The test did not execute as expected, but instead
 * encountered an unexpected error while running. For example, a
 * failed memory allocation. This is different from a failure, which
 * is caused by a failed test assertion.
 */
typedef enum ktest_result_type {
	KTEST_UNINIT,
	KTEST_PASS,
	KTEST_FAIL,
	KTEST_SKIP,
	KTEST_ERROR
} ktest_result_type_t;

typedef struct ktest_msg_result {
	char			kmr_msg_prepend[KTEST_MAX_LOG_LEN];
	char			kmr_msg[KTEST_MAX_LOG_LEN];
	char			kmr_input_path[PATH_MAX];
	ktest_result_type_t	kmr_type;
	int			kmr_errno;
} ktest_msg_result_t;

typedef enum ktest_msg_type {
	KTEST_MSG_RESULT,	/* Test result. */
	KTEST_MSG_ERROR		/* Ktest runner error. */
} ktest_msg_type_t;

/*
 * Messages returned from KTEST_IOCTL_READ_MSGS. Ktest uses these
 * message to communicate results back to userland.
 */
typedef struct ktest_msg {
	char			km_module[KTEST_MAX_NAME_LEN];
	char			km_suite[KTEST_MAX_NAME_LEN];
	char			km_test[KTEST_MAX_NAME_LEN];
	ktest_msg_type_t	km_type;
	union {
		ktest_msg_result_t	km_result;
		int			km_err;
	} km_u;
} ktest_msg_t;

#define	KTEST_READ_MSG_COUNT	4

typedef struct ktest_read_msgs_op {
	uint16_t krmo_count;	/* Num messages read. */
	boolean_t krmo_more;	/* More messages to come? */
	ktest_msg_t krmo_msgs[KTEST_READ_MSG_COUNT];  /* Message slots. */
} ktest_read_msgs_op_t;

/*
 * The following API/ABI is for the ktest modules.
 */
#ifdef _KERNEL

typedef struct __ktest_module_hdl ktest_module_hdl_t;
typedef struct __ktest_suite_hdl ktest_suite_hdl_t;
typedef struct __ktest_test_hdl ktest_test_hdl_t;
typedef struct __ktest_ctx_hdl ktest_ctx_hdl_t;

typedef void (*ktest_fn_t)(ktest_ctx_hdl_t *);
typedef int (*ktest_init_fn)();
typedef int (*ktest_fini_fn)();

/*
 * Module, suite, and test creation/registration.
 */
int ktest_create_module(const char *, const char *, ktest_module_hdl_t **);
int ktest_create_suite(const char *, ktest_suite_hdl_t **,
    ktest_init_fn, ktest_fini_fn);
void ktest_add_suite(ktest_module_hdl_t *, ktest_suite_hdl_t *);
int ktest_add_test(ktest_suite_hdl_t *, const char *, ktest_fn_t,
    ktest_test_flags_t);
void ktest_register_module(ktest_module_hdl_t *);
void ktest_unregister_module(const char *);

/*
 * Utility for getting a handle to static functions.
 */
int ktest_hold_mod(const char *, ddi_modhandle_t *);
void ktest_release_mod(ddi_modhandle_t);
int ktest_get_fn(ddi_modhandle_t, const char *, void **);

/*
 * Retrieve the input stream for a test.
 */
void ktest_get_input(const ktest_ctx_hdl_t *, uchar_t **, size_t *);

/*
 * Set the test result.
 */
void ktest_result_skip(ktest_ctx_hdl_t *, const char *, ...);
void ktest_result_fail(ktest_ctx_hdl_t *, const char *, ...);
void ktest_result_error(ktest_ctx_hdl_t *, const char *, ...);
void ktest_result_pass(ktest_ctx_hdl_t *);
void ktest_msg_clear(ktest_ctx_hdl_t *);
void ktest_msg_prepend(ktest_ctx_hdl_t *, const char *fmt, ...);

/*
 * KTest ASSERT
 *
 * If the expression fails, then stash the failure message in ctx and
 * return from the calling function.
 */
#define	KT_ASSERT_IMPL(LEFT, OP, RIGHT, TYPE, ctx) do {			\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_fail((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
		return;							\
	}								\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_ASSERT3S(l, op, r, ctx)			\
	KT_ASSERT_IMPL(l, op, r, int64_t, ctx)

#define	KT_ASSERT3U(l, op, r, ctx)			\
	KT_ASSERT_IMPL(l, op, r, uint64_t, ctx)

#define	KT_ASSERT3P(l, op, r, ctx)			\
	KT_ASSERT_IMPL(l, op, r, uintptr_t, ctx)

#define	KT_ASSERT(exp, ctx)				\
	KT_ASSERT_IMPL(exp, ==, B_TRUE, boolean_t, ctx)

#define	KT_ASSERT0(exp, ctx)				\
	KT_ASSERT_IMPL(exp, ==, 0, uintmax_t, ctx)

/*
 * KTest ASSERT Goto
 *
 * If the expression fails, then stash the failure message in ctx and
 * goto label.
 */
#define	KT_ASSERTG_IMPL(LEFT, OP, RIGHT, TYPE, ctx, label) do {		\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_fail((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
		goto label;						\
	}								\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_ASSERT3SG(l, op, r, ctx, label)			\
	KT_ASSERTG_IMPL(l, op, r, int64_t, ctx, label)

#define	KT_ASSERT3UG(l, op, r, ctx, label)			\
	KT_ASSERTG_IMPL(l, op, r, uint64_t, ctx, label)

#define	KT_ASSERT3PG(l, op, r, ctx, label)			\
	KT_ASSERTG_IMPL(l, op, r, uintptr_t, ctx, label)

#define	KT_ASSERTG(exp, ctx, label)				\
	KT_ASSERTG_IMPL(exp, ==, B_TRUE, boolean_t, ctx, label)

#define	KT_ASSERT0G(x, ctx, label)				\
	KT_ASSERTG_IMPL(x, ==, 0, uintmax_t, ctx, label)

/*
 * KTest ASSERT Block
 *
 * If the expression fails, then stash the failure message in ctx and
 * execute the block following this macro. The block must be folowed
 * with a KT_ASSERTB_END macro.
 */
#define	KT_ASSERTB_IMPL(LEFT, OP, RIGHT, TYPE, ctx) do {		\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_fail((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
	}								\
	if (!__res)

#define	KT_ASSERTB_END				\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_ASSERT3SB(l, op, r, ctx)			\
	KT_ASSERTB_IMPL(l, op, r, int64_t, ctx)

#define	KT_ASSERT3UB(l, op, r, ctx)			\
	KT_ASSERTB_IMPL(l, op, r, uint64_t, ctx)

#define	KT_ASSERT3PB(l, op, r, ctx)			\
	KT_ASSERTB_IMPL(l, op, r, uintptr_t, ctx)

#define	KT_ASSERTB(expx, ctx)				\
	KT_ASSERTB_IMPL(exp, ==, B_TRUE, boolean_t, ctx)

#define	KT_ASSERT0B(exp, ctx)				\
	KT_ASSERTB_IMPL(exp, ==, 0, uintmax_t, ctx)

/*
 * KTest ERROR Macros
 *
 * These are modeled after the KTest ASSERT macros, but are instead
 * used to check for error conditions.
 */
#define	KT_EASSERT_IMPL(LEFT, OP, RIGHT, TYPE, ctx) do {		\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_error((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
		return;							\
	}								\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_EASSERT3S(l, op, r, ctx)			\
	KT_EASSERT_IMPL(l, op, r, int64_t, ctx)

#define	KT_EASSERT3U(l, op, r, ctx)			\
	KT_EASSERT_IMPL(l, op, r, uint64_t, ctx)

#define	KT_EASSERT3P(l, op, r, ctx)			\
	KT_EASSERT_IMPL(l, op, r, uintptr_t, ctx)

#define	KT_EASSERT(exp, ctx)				\
	KT_EASSERT_IMPL(exp, ==, B_TRUE, boolean_t, ctx)

#define	KT_EASSERT0(exp, ctx)				\
	KT_EASSERT_IMPL(exp, ==, 0, uintmax_t, ctx)

/*
 * KTest ERROR Goto
 *
 * These are modeled after the KTest ASSERT Goto macros, but are
 * instead used to check for error conditions.
 */
#define	KT_EASSERTG_IMPL(LEFT, OP, RIGHT, TYPE, ctx, label) do {	\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_error((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
		goto label;						\
	}								\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_EASSERT3SG(l, op, r, ctx, label)			\
	KT_EASSERTG_IMPL(l, op, r, int64_t, ctx, label)

#define	KT_EASSERT3UG(l, op, r, ctx, label)			\
	KT_EASSERTG_IMPL(l, op, r, uint64_t, ctx, label)

#define	KT_EASSERT3PG(l, op, r, ctx, label)			\
	KT_EASSERTG_IMPL(l, op, r, uintptr_t, ctx, label)

#define	KT_EASSERTG(exp, ctx, label)				\
	KT_EASSERTG_IMPL(exp, ==, B_TRUE, boolean_t, ctx, label)

#define	KT_EASSERT0G(x, ctx, label)				\
	KT_EASSERTG_IMPL(x, ==, 0, uintmax_t, ctx, label)

/*
 * KTest ERROR Block
 *
 * These are modeled after the KTest ASSERT Block macros, but are
 * instead used to check for error conditions.
 */
#define	KT_EASSERTB_IMPL(LEFT, OP, RIGHT, TYPE, ctx) do {		\
	const TYPE __left = (TYPE)(LEFT);				\
	const TYPE __right = (TYPE)(RIGHT);				\
	const boolean_t __res = __left OP __right;			\
	if (!__res) {							\
		ktest_result_error((ctx),				\
		    "%s %s %s"						\
		    " (0x%" PRIxMAX " %s 0x%" PRIxMAX ")"		\
		    " (%s:%d)",						\
		    #LEFT, #OP, #RIGHT,					\
		    (uintmax_t)__left, #OP, (uintmax_t)__right,		\
		    __FILE__, __LINE__);				\
	}								\
	if (!__res)

#define	KT_EASSERTB_END				\
	_NOTE(CONSTCOND)  } while (0)

#define	KT_EASSERT3SB(l, op, r, ctx)			\
	KT_EASSERTB_IMPL(l, op, r, int64_t, ctx)

#define	KT_EASSERT3UB(l, op, r, ctx)			\
	KT_EASSERTB_IMPL(l, op, r, uint64_t, ctx)

#define	KT_EASSERT3PB(l, op, r, ctx)			\
	KT_EASSERTB_IMPL(l, op, r, uintptr_t, ctx)

#define	KT_EASSERTB(expx, ctx)				\
	KT_EASSERTB_IMPL(exp, ==, B_TRUE, boolean_t, ctx)

#define	KT_EASSERT0B(exp, ctx)				\
	KT_EASSERTB_IMPL(exp, ==, 0, uintmax_t, ctx)

#endif	/* _KERNEL */

#ifdef __cplusplus
}
#endif

#endif /* _SYS_KTEST_H */
